<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<script>
		'use strict';

		let searchDepth = 8;
		let width = 7;
		let height = 6;
		let winLength = 4;
		let winDirs = [
			{x: 1, y: 0},
			{x: 1, y: 1},
			{x: 0, y: 1},
			{x: -1, y: 1}
		];
		let useCache = true;

		let cache = {};

		let stepCounter;
		let p1PruneCounter;
		let p2PruneCounter;
		let p1LossPruneCounter;
		let p2LossPruneCounter;
		let cachePruneCounter;

		function createField() {
			let field = new Array(width);
			field.fill(new Array(height));
			field.map(row => row.fill(0));

			return field;
		}

		function createWinMask() {
			let winMask = [];

			for (var x = 0; x < width; x++) {
				for (var y = 0; y < height; y++) {
					for (var i = 0; i < winDirs.length; i++) {
						let winDir = winDirs[i];
						let winRow = [];

						for (var d = 0; d < winLength; d++) {
							let dx = d * winDir.x;
							let dy = d * winDir.y;

							let x2 = x + dx;
							let y2 = y + dy;

							if (0 > x2 || x2 > width - 1 || 0 > y2 || y2 > height - 1) {break;}

							winRow.push({x: x2, y: y2});
						}

						if (winRow.length == winLength) {
							winMask.push(winRow);
						}
					}
				}
			}

			return winMask;
		}

		function throwCoin(field, col, player) {
			let fieldClone = [];
			field.forEach(col => fieldClone.push([...col]));

			let amountInCol = fieldClone[col].filter(item => item > 0).length;

			if (amountInCol > height - 1) {throw new Error('Col full')}

			fieldClone[col][amountInCol] = player;

			return fieldClone;
		}

		function checkWin(field, winMask, player) {
			let win = false;

			winMask.forEach(winRow => {
				for (var j = 0; j < winRow.length; j++) {
					let {x, y} = winRow[j];

					if (field[x][y] != player) {break}

					if (j == winLength - 1) {
						win = true;
					}
				}
			});

			return win;
		}

		function buildPredictionTree(field, winMask, player, depth = searchDepth) {
			stepCounter++;
			let moves = [];

			for (var i = 0; i < width; i++) {
				try {
					let fieldClone = [];
					field.forEach(col => fieldClone.push([...col]));

					let newField = throwCoin(fieldClone, i, player);

					moves.push(newField);
				}catch{}
			}

			moves = moves.map(move => {
				let cachedItem = getFromCache(move);
				if (cachedItem) {
					cachePruneCounter++;
					return cachedItem;
				}

				let p1Wins = checkWin(move, winMask, 1);
				let p2Wins = checkWin(move, winMask, 2);

				if (p1Wins) {
					addToCache(move, {p1Wins: 1, p2Wins: 0, und: 0});
					return {p1Wins: 1, p2Wins: 0, und: 0};
				}
				if (p2Wins) {
					addToCache(move, {p1Wins: 0, p2Wins: 1, und: 0});
					return {p1Wins: 0, p2Wins: 1, und: 0};
				}
				if (depth == 0) {
					addToCache(move, {p1Wins: 0, p2Wins: 0, und: 1});
					return {p1Wins: 0, p2Wins: 0, und: 1};
				}

				return move;
			});

			let p1WinCount = moves.filter(move => !Array.isArray(move) && move.p1Wins == 1).length;
			let p2WinCount = moves.filter(move => !Array.isArray(move) && move.p2Wins == 1).length;

			if (player == 1 && p1WinCount >= 1) {
				p1PruneCounter++;
				return {p1Wins: 1, p2Wins: 0, und: 0}
			}
			if (player == 1 && p2WinCount >= 2) {
				p1LossPruneCounter++;
				return {p1Wins: 0, p2Wins: 1, und: 0}
			}
			if (player == 2 && p2WinCount >= 1) {
				p2PruneCounter++;
				return {p1Wins: 0, p2Wins: 1, und: 0}
			}
			if (player == 2 && p1WinCount >= 2) {
				p2LossPruneCounter++;
				return {p1Wins: 1, p2Wins: 0, und: 0}
			}

			moves = moves.map(move => {
				if (Array.isArray(move)) {
					return buildPredictionTree(move, winMask, player == 1 ? 2 : 1, depth - 1);
				}else {
					return move;
				}
			});

			let result = moves.reduce((acc, cur) => 
				({
					p1Wins: acc.p1Wins + cur.p1Wins,
					p2Wins: acc.p2Wins + cur.p2Wins,
					und: acc.und + cur.und
				})
			, {p1Wins: 0, p2Wins: 0, und: 0});
			addToCache(field, result);
			return result;
		}

		function createCacheKey(field) {
			return "".concat(...field.map(col => "".concat(...col)));
		}

		function getFromCache(field) {
			if (!useCache) {return undefined}

			let key = createCacheKey(field);

			return cache[key];
		}

		function addToCache(field, value) {
			if (!useCache) {return}

			let key = createCacheKey(field);

			cache[key] = value;
		}

		function test() {
			let field = createField();
			let winMask = createWinMask();

			stepCounter = 0;
			p1PruneCounter = 0;
			p2PruneCounter = 0;
			p1LossPruneCounter = 0;
			p2LossPruneCounter = 0;
			cachePruneCounter = 0;

			let startTime = (new Date()).getTime();
			console.log(buildPredictionTree(field, winMask, 1));
			console.log("run-time:" + ((new Date()).getTime() - startTime) / 1000);
			console.log(`steps:${stepCounter}`);
			console.log(`p1-prunes:${p1PruneCounter}`);
			console.log(`p2-prunes:${p2PruneCounter}`);
			console.log(`p1-loss-prunes:${p1LossPruneCounter}`);
			console.log(`p2-loss-prunes:${p2LossPruneCounter}`);
			console.log(`cache-prunes:${cachePruneCounter}`);
		}

		function depthTest() {
			let depths = [1,2,3,4,5,6,7,8,9,10];
			for(let depth of depths) {
				searchDepth = depth;
				cache = {};
				console.log(`---- DEPTH SET TO ${depth} ----`);
				test();
			}
		}
	</script>
</body>
</html>